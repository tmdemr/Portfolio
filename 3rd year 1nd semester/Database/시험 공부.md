# 무결성 제약
- 무결성
  - 데이터베이스에 저장된 데이터가 실제 세계에 존재하는 정보들을 모순 없이 반영하는 성질
  - 데이터베이스에 저장된 데이터가 갖추어야 할 제약 조건을 항상 만족하도록 보장하는 성질
- 기본적 무결성 제약
  - 관계형 데이터 모델에서 정의한 무결성 제약
    - 기본키 무결성 제약
    - 참조 무결성 제약

- 테이블 무결성 제약
  - 테이블을 정의하거나 변경 과정에서 설정 가능한 무결성 제약
    - NOT NULL
    - UNIQUE
    - CHECK
    - DEFAULT

- 기타 무결성 제약
  - 위의 방법으로 정의할 수 없는 무결성 제약
    - 주장
    - 트리거
    - 데이터베이스 프로그래밍을 이용한 무결성 제약 설정


## SQL 권한 제어
- GRANT
  - 권한을 부여하는 명령
```SQL
GRANT <권한 리스트> on <객체명> to <사용자리스트>

grant select on student to kim
-- kim에게 student 테이블에 대한 select 연산 수행 권한 부여

grant select, delete on student to kim
-- delete와 select권한 부여

grant references (dept_id) on department to kim;
-- department 테이블을 참조하는 외래키를 포함하는 테이블의 생성이 가능

grant all privileges on student to lee;
-- 모든 권한 부여

grant select on student to kim with grant option;
-- student 테이블에 select 권한을 부여받은 kim은 with grant option으로 권한을 다른 사용자한테 다시 전파할 수 있는 자격을 얻음.

```

- REVOKE
  - 다른 사용자에게 부여한 권한을 회수하기 위해 사용

```SQL
revoke <권한 리스트> on <객체 명> from <사용자 리스트>

revoke select on student from kim;
```

- ROLE
  - 권한 별로 그룹을 만들어 그룹에 권한을 부여하는데 사용됨
```SQL
create role <그룹 이름>

create role employee;
```

# 데이터 베이스 설계
- 사용자의 요구사항으로부터 현실세계를 반영한 데이터베이스의 구조를 도출해 내는 과정
- 데이터 베이스 설계 단계
  - 요구사항 분석
    - 데이터베이스를 활용하게 되는 업무 내용, 운영 환경, 처리 조건 등을 분석하여 데이터베이스가 제공해야 하는 핵심적인 정보 대상 및 제한 조건 등을 도출하는 단계
  - 개념적 설계
    - 요구사항 분석에서 나온 결과를 토대로 핵심 정보 개체, 제한 조건 등을 특정 DBMS에 독립적이면서 추상화된 표현 방식으로 기술하는 단계이며, 그 결과로서 개념적 스키마를 생성
  - 논리적 설계
    - 개념적 설계 단계에서 구성된 개념적 스키마로서 관계형 데이터 모델과 같이 논리적 데이터베이스 구조에 맞는 스키마를 생성하는 단계이며 그 결과로서 테이블 스키마를 생성
  - 물리적 설계
    - 논리적 설계 단계에서 생성된 논리적 데이터베이스 구조로부터 효율적이고 구현 가능한 물리적 데이터베이스 구조를 설계하는 단계

> 실생활에 존재하는 데이터 베이스를 이용한 요구 분석을 하고, 개념적 설계 및 논리적 설계를 하여 해당 테이블 스키마를 정규화여 표현하기

# 정규화
## 정규화란?
- 불필요한 데이터 중복을 피하기 위해 스키마 분해

## 정규화의 효과
- 테이블에 대한 삽입, 삭제, 수정 등의 연산으로 인해 발생할 수 있는 이상현상을 방지하는 수단을 제공
- 데이터 중복으로 발생하는 문제 해결
- 단, 함수적 종속이 유지 될 수 있도록 데이터베이스 설계해야 함.

## 정규형이란?
- 각 단계별 정규화 과정을 통해 분해된 테이블들

## 정규형의 관계
- 비정규 릴레이션
  - 도메인이 원자 값
- 1차 정규형(1NF : first normal form)
  - 부분적 함수 종속 제거
- 2차 정규형(2NF : second normal for)
  - 이행적 함수 종속 제거
- 3차 정규형(3NF : third normal for)
  - 결정자이면서 후보키가 아닌 것 제거
- 보이스-코드 정규형(BCNF : Boyce-Codd normal form)
  - 다치 종속 제거
- 4차 정규형(4NF : forth normal for)
  - 조인 속성 이용
- 5차 정규형(5NF : fifth normal for)

### 1차 정규형
- 정의
  - 테이블 R에 속한 모든 도메인이 원자값(atomic value)만으로 구성되어 있다면 R은 1차 정규형이다.
- 관계형 데이터 모델의 정의를 따르는 모든 테이블은 1차 정규형
- 다음의 register 테이블도 1차 정규형
- 1차 정규형의 문제점
  - 삽입 이상
    - 학번이 '1292502'인 학생이 '전자공학과'에 소속된다는 사실을 삽입하려면 최소한 그 학생이 하나의 과목을 수강해야만 가능
  - 삭제 이상
    - stu_id가 '1292301'인 학생이 '자료구조'를 수강한다는 사실을 삭제하면 이 학생이 '산업공학과'에 소속된다는 정보까지 동시에 삭제
  - 수정 이상
    - 학번이 '12292001'인 학생의 소속이 '컴퓨터공학과'에서 '산업공학과'로 변경하면 모든 해당 레코드를 변경해야 함.
  - 문제 발생 원인
    - 부분 종속(partial dependency) : 키가 아닌 필드(A)가 키의 일부인 필드(X)에 종속되는 경우
  - register 테이블
    - 기본키 : (stu_id, title)
    - dept_name 필드는 stu_id에 함수적 종속
    - std_id가 동일한 레코드에 대해 dept_name이 중복해서 나타남

### 2차 정규형
- 정의
  - 테이블 R에서 키가 아닌 모든 필드가 키에 함수적으로 종속되며
  - 키의 부분집합이 결정자가 되는 부분 종속이 존재하지 않으면
  - R은 2차 정규형이다.

- 하나의 필드로 키가 되는 경우 모두 2차 정규형에 해당
- 1차 정규형의 문제(삽입/수정/삭제 이상)가 발생하지 않는다.

- 완전 함수 종속(full functional dependency)
  - A와 B가 릴레이션 R의 속성이고 A -> B 종속성이 성립할 때, B가 A의 속성 전체에 함수 종속하고 부분집합 속성에 함수 종속하지 않을 경우 '완전 함수 종속'이라고 한다.
- 2차 정규형의 문제점
  - 문제 발생의 원인
    - 기본 키의 이행 종속
  - 해결방안
    - 이행 종속에 참여한 필드들을 다른 테이블로 분해

### 테이블 분해 조건
- 무손실 조인 분해

  - 일반적으로 테이블 R이  R1, R2 로 분해되었을 때 두 테이블을 조인한 것에 원래 테이블이 포함됨.
  - 즉, 분해된 테이블을 자연 조인하면 원래의 테이블과 일치해야 함.
- 무손실 분해 조건
  - 분해된 테이블의 공통 필드 집합이 둘 중 하나의 테이블에서 키가 된다면 무손실 조인 분해가 된다.

### 3차 정규형
- 정의
  - 테이블의 R이 2차 정규형이면서 키에 속하지 않은 모든 필드가 기본키에 이행 종속되지 않는다면 R은 3차 정규형이다.
  
- 릴레이션 R이 제 2정규형이고 기본키가 아닌 속성이 기뵈에 비이행적 non-transitive으로 종속할 때(직접 종속) 제 3정규형이라고 한다. 
- 이행적 종속이란 A -> B, B -> C가 성립할 때, A -> C가 성립되는 함수 종속성을 말한다.

### 보이스-코드 정규형
- 정의
  - 테이블 R에 존재하는 모든 함수적 종속에서 결정자가 후보키이면 R은 보이스-코드 정규형이다.
- 릴레이션 R에서 함수 종속성 X -> Y가 성립할 때 모든 결정자 X가 후보키면서 BCNF 정규형이라고 한다.

## ER 스키마로부터 테이블 스키마로의 변환 규칙의 요약
- 강성 개체집합의 변환
  - 개체집합의 속성은 테이블의 필드로 정의
  - 개체집합의 기본키는 테이블의 기본키로 정의
- 약성 개체집합의 변환
  - 개체집합의 속성은 테이블의 필드로 정의
  - 약성 개체집합의 기본키는 자신의 부분키와 해당 강성 개체집합의 기본키로 구성
- 관계집합의 변환
  - 관련 개체집합의 기본키들과 자신의 속성을 필드로 하여 테이블을 정의
  - 해당 테이블의 기본키는 관련 개체집합의 기본키들의 집합으로 정의
- 관계형 테이블의 중복 제거
  - 약성 개체집합 및 일 대 다 대응관계를 가지는 경우, 관계집합에 해당하는 테이블을 삭제
  - 다 측 테이블에 일 측 테이블의 기본키를 가지고 옴
- 자기연관 관계 집합의 변환
  - 일 대 다 관계인 경우, 관계집합에 해당하는 테이블을 정의할 필요가 없지만, 일 측에 해당하는 역할을 감안하여 새로운 필드를 정의
  - 다 대 다 관계의 경우, 해당 관계집합의 기본키에 해당하는 2개의 필드를 정의하되, 역할에 따른 필드명을 부여
- 다중값 속성의 변환
  - 복합 속성 자신의 속성과 관련 개체집합의 기본 키로 구성되는 별도의 테이블을 정의
  - 생성된 테이블의 기본키는 해당 개체집합의 기본키로 설정
- 복합 속성의 변환
  - 복합 속성에 존재하는 세부 속성만으로 필드를 정의
- 일반화 관계 집합의 변환
  - 상위 개체집합을 유지하는 경우, 하위 개체집합에 해당하는 테이블은 상위 개체집합의 기본키를 가져옴
  - 상위 개체집합을 유지하지 않는 경우, 하위 개체집합에 해당하는 테이블은 자신의 속성과 상위 개체집합의 모든 속성을 포함하여 필드를 정의