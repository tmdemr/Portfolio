# 메모리 관리

## 단편화
- 외부 단편화
  - 프로세스들이 기억 장치에 적재되고 제거될 때, 가용 기억 공간은 연속적이지 않은 많은 작은 조각으로 나누어져 할당 요청을 만족시킨다.
- 내부 단편화

## 압축(compaction)
- 외부 단편화 문제의 해결
  - 메모리의 여러 영역들을 옮겨 모든 작은 빈 공간들을 연속된 하나의 큰 빈 공간으로 만드는 작업
  - 동적인 재배치가 가능하고 수행시간에 이루어지는 경우에만 가능
  - **조각모음과 비슷한 형상임**

## 압축의 비용
- 간단한 압축 알고리즘
  - 모든 작업을 기억장치의 한쪽 끝으로 이동시켜 모든 빈 공간이 그 반대 방향으로 이동되어 하나의 큰 기억장소를 만든다.
- 압축의 비용 = 압축된 프로세스들의 크기의 합

## 8.4 페이징
- 기본적인 메모리 관리 기법
- 단편화의 문제를 해결하기 위해 프로그램 전체를 불연속적인 페이지라는 단위로 나누어 적재.
- 각 페이지가 어디에 있는지 추적해야 하기 때문에 오버헤드 발생.
  
### 페이지 테이블
- 논리 기억 장치
  - 페이지라 불리는 같은 크기의 블록들로 구성
  - 
- 물리 기억 장치
  - 프레임이라 불리는 고정 크기 블록으로 구성

### 페이지 크기
- 페이지 크기는 하드웨어에 의해 결정
  - 일반적으로 2의 누승
  - 대체로 페이지 당 512byte ~ 16Kbytes
- 논리 주소 = 페이지 번호 + 페이지 오프셋(한 페이지 내에서 몇 번 주소인지를 나타내는 값)
  - 예) 논리 주소의 크기 = 2의 m승, 페이지 크기 = 2의 n승

### 특징
- 페이징 자체는 동적 재배치의 형태
- 메모리의 사용자 관점과 물리 메모리 사이의 명확한 구분
- 외부 단편화는 발생하지 않는다.

### 페이지 테이블의 구현
- 전용 레지스터의 집합
  - 페이지 테이블이 작은 경우 상관 x
- 페이지 테이블을 주기억 장치에 유지
  - 페이지 테이블 기준 레지스터(PTBR)가 페이지 테이블을 가리킨다.
  - 기억 장치 위치에 접근하는데 많은 시간 소요
    - 한 워드에 접근하기 위해 두 번의 기억장치 접근 필요
- TLB(translation look-aside buffer 사용)
  - 특수한 작은 하드웨어 캐시 - 빠른 연관 메모리
  - 탐색은 빠르지만 하드웨어가 고가임
  - FIFO 방식으로 관리

### 실제 접근 시간(Effective Access Time)
- 알파가 커서 2보다 작은 결과 값이 나온다면, TLB를 사용하는 것이 더 효율적이다.

### 8.4.3 페이지 보호
- 페이지 테이블에 보호용 비트 추가
  - 페이지 단위로 판독 전용, 판독/기록 전용, 실핸 전용 등의 보호 지정
- 타당(유효/무효) 비트 추가
  - 페이지에 대한 사용을 금지할 수 있다.

> 예를 들어, 페이지 비트 내부에 보호용 비트를 할당하고, 2개의 비트를 할당하고 00은 Read Only, 01은 Read&Wright, 10은 Excution 전용 등으로 나누는 것이 가능함.  
> 또한 유효 또는 무효 비트를 추가하여 사용이 가능 또는 불가능하게 만드는 방법이 있음.

### 해시 페이지 테이블
- 32비트 보다 큰 주소 공간을 다룰 때 사용
- 같은 위치로 해시하는 요소들의 리스트로 구성.
- pid와 page number를 찾아야 한다는 치명적인 단점이 있음.


> ### 각 프로세스마다 페이지 테이블을 따로 만들어야 함!!

### 공유 페이지
읽어봐야함.

## 8.4 세그먼테이션(Segmentation)
- 기억장치에 대한 사용자 관점을 지원하는 기억 장치 관리 방법
- 세그먼트 - 메모리의 가변적인 단위
  - 서브루틴, 함수, 테이블, 행렬, 스택 등
- 프로그램은 세그먼트들의 집합.