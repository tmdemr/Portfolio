## 역 페이지 테이블
- 모든 프로세스가 하나의 큰 페이지 테이블을 공유함
- cpu가 만들어낸 논리적은 주소(pid 등)를 참조하여 페이지를 찾아낸다.


## 사례 ; 인텔 32비트 및 64비트 구조
- 세그먼테이션과 페이지화된 세그먼테이션을 모두 지원
- CPU는 논리 주소를 생성

- SI(Source Index)는 인덱스의 시작 주소를 지정.

### 페이지화된 세그먼테이션
- Intel Pentium 구조
  - 논리 주소 = selector(16 bit) + offset(32 bits)
    - Selector 는 수식자 테이블(LDT 또는 GDT)로부터 세그먼트 선택
  
# Chapter 9. 가상 메모리
- 프로세스 전체가 메모리에 올라오지 않더라도 실행.

## 9.1 가상 메모리의 배경
- 가상 메모리는 m < n, 부분 적재 실행, 페이지 단위 사상
- 부분 적재 실행의 타당성
  1. 항상 전체 프로그램이 실행되는 것은 아니다.
      - 오류 루틴 : 프로그램에서 오류는 거의 발생하지 않음.
      - 행렬, 리스트, 테이블 등 : 실제 필요한 양보다 크게 선언되는 경향.
  2. 전체 프로그램 요구 시에도, 똑같은 시간에 모두 요구되지는 않음.
- 부분 적재 실행의 장점
    1. 프로그램은 메모리 크기에 의해 제약받지 않음 - 중첩 불필요.
    2. 보다 많은 사용자들이 동시에 시행 가능 = CPU 활용도/처리율 개선
    
## 가상 메모리의 배경
- 부분 적재 실행에서 해결해야 할 문제
  1. 디스크와 메모리 사이의 페이지 이동량이 과다해질 수 있으므로 교체(swap) 공간 운연
      - 교체 공간은 일반 파일보다 상당히 효율적인 입출력 가능.
  2. 반입 정책 : 언제 어떤 페이지를 적재하고 어떤 경우에 페이지를 교체할 것인가 하는 페이징 알고리즘을 선택
  3. 교체 정책 : 페이지 교체 알고리즘은 구체적으로 교체될 희생자를 선택하는 시스템.
  4. 할당 정책 : 한 프로세스에 필요한 프레임의 수와 이 프레임을 차지하는 페이지 구성 문제
- 가상 메모리 구현
    1. 요구 페이징
    2. 요구 세그먼테이션

## 9.9 기타 요구 사항
- 프리페이징
  - 과도한 페이지 부재를 방지하기 위해 프로세스와 관련된 모든 페이지를 사전에 한꺼번에 메모리로 할당
- 페이지 크기 선택
  - 단편화
  - 테이블 크기
  - I/O 오버헤드

- 프로그램 구조
  - int A[][] = new int [1024][1024];
  - 각 행은 한 페이지에 저장
  
- 입/출력 상호 잠금 = 페이지는 때로 메모리 내에 잠궈져야 한다.
- 장치로부터 파일을 복사하는데 사용되는 페이지들은 페이지 교체 알고리즘에 의해 퇴출되지 않도로 잠궈져야 한다.

### Window XP
- 클러스터링 방식의 요구 페이징
  - 클러스터링으로 부재 페이지 및 추변도 함께 가져옴.

### Solaris
- 페이지 부재 프로세스들에 자유 페이지 리스트로부터 페이지를 할당
