# Chapter 11. 파일 시스템
## 11.1 파일 시스템 구조
- 파일 구조
  - 논리적 저장 단위
  - 관련 정보의 집합
- 물리적 보조기억 장치에 논리적 파일 시스템을 사상시키기 위한 알고리즘 필요
- 계층적 구조 사용
- 파일 제어 블록
  - 파일에 대한 정보를 구성하는 저장 구조

## 11.2 파일 시스템 구현
- 디스크 구조
  - 부트 제어 블록
    - 시스템 부팅에 필요한 정보
    - UFS - 부트 블록, NTFS - 파티션 부트 섹터
      - 보통 디바이스의 0번 주소에 위치.
      - OS가 어디있고,,, 등등에 대한 주소에 대한 정보를 저장
  - 파티션 제어 블록
    - 한 하드 디스크를 논리적으로 여러 개로 나누는 것에 대한 정보(파티션 블록 수, 크기, 자유 블록 수와 포인터)를 담음.
  - 디렉토리 구조

  - 파일 제어 블록(FCB)
    - 파일 허가, 소유, 크기 등 자세한 파일 정보
      - permission
      - dates(create, acess, write)
      - owner group, ACL
      - size
      - data blocks or pointers to file data block
    - UFS - inode, NTFS- 마스터 파일 테이블 안에 저장.


> 각 프로세스마다 사용할 수 있는 파일에 대한 정보를 담은 테이블을 가지고 있음.
> 별다른 파일 작업을 수행하지 않는 프로세스도 3개의 파일(stdio 관련)은 오픈함.

## 가상 파일 시스템
- 여러 종류의 파일 시스템에 대하여 같은 시스템 호출 인터페이스 사용
> 실제로 C에서 구현할때는 함수 포인터를 사용하여 구현.
```C
struct file_operation{
    int *open();
    void *read();
    void *write();
}

fd = open("file.txt", O_READONLY);
```

## 11.3 디렉토리 구현
- 선형 리스트
  - 파일 이름을 가진 선형 리스트
  - 프로그램 용이
  - 실행하는데 시간이 걸림.

- 해시 테이블
  - 해시 자료 구조를 가진 선형 리스트.
  - 디렉토리 탐색 시간 감소
  - 충돌(collisions) 발생 가능
    - 두 개의 파일 이름이 같은 위치로 해시하는 상황
  
## **11.4 할당 방법**
### 11.4.1 연속 할당
- 각 파일들은 디스크의 선형적으로 연속된 기억 공간을 할당
- 간단함
  - 블록들의 시작 주소와 개수만 필요
- 랜덤 접근
- 빈 공간의 낭비
  - 외부 단편화
- 파일에 필요한 공간의 확장이 어렵다.

### 연속 할당
- 각 블록마다 데이터를 할당하고, 블록의 끝에 다음 블록의 주소를 할당
- 간단함 - 시작 주소만 필요
- 순차 접근 파일에만 효과적(중간 데이터에 접근하려면 첫 번째 데이터부터 읽어와야 함.)
- 신뢰성 문제
- 많은 새로운 파일 시스템(예, Veritas File System)이 수정된 연속 할당 방식 사용
- Extent - 기반 파일 시스템은 디스크 블록을 extents에 할당.
  - extent - 연속된 디스크 블록들
  - 파일 할당을 위해 할당. 파일은 하나 이상의 extent로 구성.

> 배드 섹터 : 하드디스크를 읽다가 바늘이 물리적으로 저장 공간을 긁어 사용할 수 없게 되는 현상.

### 파일 할당 테이블;FAT
- MS-DOS, OS/2 에서 사용
- 각 디스크 블록 내의 블록 번호와 관련 포인터의 항목 테이블을 가지고 블록 번호에 의해 참조.
- 포인터 테이블의 마지막 항목은 -1로 더 이상 디스크 블록이 없다는 것을 의미함.

### 11.4.3 색인 할당
- 색인 블록에 파일 포인터들을 관리
  - 색인의 I 번째 항목이 파일의 I번 째 블록으로 연결
- 랜덤 접근 - 외부 단편화 없이 동적 접근 가능
- 색인 블록에 대한 메모리 낭비
- 해결 방법
  - 연결 기법 - 색인 블록들을 연결
  - 다중 단계 색인 - 여러 단계의 직/간접 테이블 색인 블록 사용
  - 결합 기법 - 직접/단일 간접/이중 간접/삼중 간접 블록 등 다양한 색인 블록 사용, UNIX 등에서 사용

## 11.5 빈 공간 관리
- 비어있는 모드 디스크 블록들을 등록
  - 비트 벡터
    - 블록이 비어있으면 0, 할당되어 있으면 1 
  - 연결 리스트
    - 모든 빈 공간을 포인터로 연결
    - 다음 빈 공간 탐색 또는 새 빈 공간 추가 시 오버헤드
  - 그룹핑
    - 첫 번째 빈 공간 내에서 n개의 빈 공간의 주소 저장
  - 계수
    - 첫 번째 빈 공간 주소와 연속된 빈 공간들의 계수 보존

## 11.6 효율과 성능
- 효율이 의존하는 것
  - 디스크 할다과 디렉토리 알고리즘
  - 파일의 디렉토리 항목에 유지되는 데이터 종류
- 성능
  - 디스크 캐시 - 자주 사용되는 블록을 위한 주 메모리의 분리된 부분
  - free-behind 와 read-ahead -> 순차 접근을 최적화 하는 기법들
  - 메모리의 일부분을 가상 디스크 또는 RAM 디스크로 전용함으로써 PC 성능 개선

### 페이지 캐시
- Memory-mapped I/O 는 페이지 캐시 사용 
- 페이지 캐시(page cache)

### 통합 버퍼 캐시

## 11.7 복구
- 일관성 점검

### 로그 구조(log structured) 또는 저널링 파일 시스템
- 파일 시스템의 매 갱신을 트랜잭션으로 기록
  - 시스템 일관성 유지 및 복구 문제 해결
  - 모든 트랜잭션은 로그에 쓰여지면, 승인된 것으로 간주하지만, 파일 시스템은 아직 갱신되지 않았을 수 있다.
  - 로그 내의 트랜잭션들은 비동기적으로 파일 시스템에 쓰여지고, 파일 시스템이 수정될 때 트랜잭션은 로그로부터 제거
  - 파일 시스템이 파손되면, 로그 내의 모든 남은 트랜잭션들은 수행되어야 한다.
  - NTFS, VFS, JFS, ReiserFS, XFS, ext3 

### NFS(Network File System)
- LAN(또는 WAN) 을 통해 원격 파일에 접근하기 위한 소프트웨어 시스템의 구현과 사양

- 데이터 프로그램 프로토콜(UDP)/IP 프로토콜과 이더넷을 사용하여 Solaris와  SunOS운영체제의 일부분으로 구현
- 서로 연결된 워크스테이션의 집합을 독립적인 파일 시스템을 가진 독립적인 기계들의 집합으로 본다.
- 파일 시스템들 사이에서 일정 수준의 공유를 투명하게 허용

### NFS의 사양
- 서로 다른 기계, 운영체제 네트워크 그조로 구성된 이질적 환경에서 동작하도록 설계.
  - NFS 사양은 이들 매체에 독립적임
- 독립성은 두 개의 구현 독립적 인터페이스간에 사용되는 External Data Representation(XDR) 프로토콜 위에 구축한 RPC 프리미티브의 사용을 통해 달성.

- NFS 사양에서의 두 가지 구분
  - 마운트 기법에 의해 제공되는 서비스 - 마운트 프로토콜
  - 실제 원격 파일 접근(remote-file-access) 서비스 - NFS 프로토콜

- 실제 사용 방법.
```shell
 $ mount -t nfs userid@hostIP: /localFile /HostFile
```

