# 정렬
## 2.1 기본 개념
- 리스트에 주어진 여러 개의 원소를 순서대로 재배치하는 것
- 내부(internal) 정렬
  - 모든 원소의 리스트가 주기억장치에 있는 대부분의 정렬
- 외부(external) 정렬
  - 대부분의 자료가 외부 기억장치에 존재하는 경우

- 안정적(stable)  정렬
  - 동일한 키를 갖는 레코드쌍의 상대적인 위치가 정렬 후에도 그대로 유지
- 제자리(in-place) 정렬 
  - 입력 배열 이외의 별도 메모리에 저장되는 원소의 개수가 상수개(입력에 n이 붙지 않음)가 넘지 않는 정렬 알고리즘
### 비교 기반
- 크기를 이용해 비교
- 선택, 삽입, 버블, 쉘 정렬
  - $O(n^2)$ ~ $O(n^3/2)$

- 퀵, 머지, 힙 정렬
  - $O(n*log n)$

- radix(기수), count 정렬
  - $O(n)$

## 선택 정렬의 특징
- 모든 키는 일단 제자리를 잡으면 이동하지 않음
  - 레코드의 크기는 크고 레코드의 총 개수는 적은 파일을 정렬하는데 적절
  - 제자리 정렬
  - 교재의 알고리즘은 불안정적이지만, 안정적 알고리즘을 만드는 것도 가능
  - 비교 횟수 : $(n-1) + (n-2) + ... = n(n-1)/2 => O(n^2)$

## 삽입 정렬
- 좌측으로부터 한 원소씩 제 자리에 삽입하는 방법
- $O(n^2)$ 시간 알고리즘
- 최악일 경우
  - 키가 내림차순으로 이미 정렬되어 있는 경우
  - $2+3+....+n = n(n+1)/2-1$ 회의 배교
  - 평균 비교 횟수도 $O(n^2)$

## 쉘 정렬
- 삽입 정렬을 확장한 것으로 멀리 떨어진 원소를 교환하여 속도를 빠르게 한 것임
- h-정렬
  - 거리가 h인 자료들간에 삽입 정렬을 행함
- 쉘 정렬은 1로 끝나는 일련의 h값에 대하여 h-정렬을 수행함
- 제자리 정렬이지만 불안정하다
- 평균 비교 횟수는 $O(n^3/2)$를 넘지 않음 


## Merge 정렬
- 분할 정복 방식
- 동일한 크기의 두 부분배열로 분할하여 이 두 부분배열을 순환적으로 정렬한 후 합병하는 방식
- 최악의 수행 시간이 $O(n log n)$이며, $O(n)$의 메모리가 별도로 필요

## 힙 정렬
- 우선순위 큐-자료가 삭제될 때 우선순위 순서에 따라 삭제되는 큐
- 히프는 우선순위 큐를 구현하는 한 가지 방법
  - 완전 이진 나무
  - 노드의 값이 자식들의 값보다 크거나 같아야 함
- 두 단계로 구성
  1. 정렬하려는 1차원 배열을 히프로 변환
  2. 히프에서 최대값을 차례로 제거하면서 키를 정렬
### 복잡도 : $O(nlogn)$

## 계수 정렬
- 1부터 k사이의 작은 정수 범위에 있을 때 적용할 수 있는 함수
- Stable 정렬임
### 복잡도 : $O(n)$


## 기수 정렬
- 전체 키를 여러 자리로 나누어 각 자리마다 계수 정렬과 같은 안정적 정렬 알고리즘을 적용하여 정렬하는 방법
- Stable 정렬
- d자리수에 대해 각 자리수에 계수 정렬을 적용 - $O(dn)$
  - d를 상수로 간주한다면 $O(n)$시간
- 비 제자리 정렬이므로 메모리 크기가 크지 않으면 사용하기 어려움.
### 복잡도 : $O(n)$
> Word : CPU가 한 번에 처리할 수 있는 데이터의 최대 크기

## 버킷 정렬
- 키 값을 n등분하였을 때 그 각 부분구간을 버킷이라고 함
- 입력 키를 버킷에 넣고 각 버킷에 대하여는 삽입 정렬을 적용하고 마지막으로 버킷을 차례대로 묶어서 정렬

## 선택(selection) 문제
- 임의로 나열된 n개의 데이터에서 크기가 i번째인 것을 찾는 문제
  - i=1 : 최소치 문제
  - i=n : 최대치 문제
    - $O(n)$시간
  - 일반적인 경우 : 정렬후 i 번째 원소 선택
    - $O(nlogn)$시간, 평균도 $nlogn$

- 최대값이나 최솟값 찾기 : $O(n)$
- 최대값과 최소값을 동시에 찾기 : 
  - 처음 두 값을 한 번 비교하고, 다음으로 들어오는 값 두 개를 서로 비교하여 S, L을 구한 후 min, S와 max,L을 비교하여 최댓값과 최솟값을 $O(3/2*n)$로 구할 수 있음

- selection_N2()의 최악의 경우
  - 해결책 : 첫 값과 끝 값의 중간 값을 시작으로 하여 최악의 경우가 발생하는 것을 방지

- i 번째 크기 원소 찾기
  - 피봇을 찾고 피봇을 기준으로 탐색하여 최악의 경우가 발생하는 것을 방지
  - 전체 배열을 5개씩 나누어 5개 중 중간값을 찾고, 그 중간값들의 중간값을 찾은 후 탐색하도록 함.



